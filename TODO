FIXME:
 - add basic ssl support, with ifdef guards, see lessandro's patch
 - remove server channel from channel list? does this break searching?
   what benefit is there to this? s->channel can then just be s->clist.head
 - are join/part/quit messages working with the threshold?
 - server: channel/ulist/clist

 - when reconnecting, if cant rejoin channel (e.g. archlinux) and bumped
   to -unregistered... closing it causes 442: not on that channel...
   what happens to messages sent to it?
	If in ##channel that requires authentication (ie bumps you to ##channel-unauthorized
	or similar), /disconnect, /connect, rirc attempts to join ##channel, can't, and is
	bumped to ##channel-unauthorized, but ##channel buffer remains open and not flagged
	as parted, ie could potentially send messages to the channel, but won't receive any
		- or it returns 403, and cant /join the channel because it's not parted

TODO:
 - Make sure all the thread related code is using thread-safe functions,
   and that proper cancellation points are used. Make sure no resources
   can be left hanging (eg: sockets left open when a thread is canceled?)

---------------------------
Continue refactoring:
	- Error/warning writing from stateless components, e.g.:
		- mode.c should be able to call err("...") on some passed parameter
		  and have it written to the appropriate buffer with the appropriate
		  `from`, etc
		- this should be easily overridden in testing to assert the right error
		  messages are being reported (fix current mock newline/newlinef)
		- this code might live in state.c, should be callable from anywher (e.g. mesg.c)
		- review stateless components and add any extra errors/warnings that could
		  be added
	- more debug information, levels, for various events, a debug pannel as a new channel
	  type when debug flag is set
	- split action handling out

action_error
display error to user for confirmation, e.g. :connect <server>
when connections are maxed

get termcap strings in draw.c on startup

fuzzy search > substring search for channels

Testing:
	- Stateful code integration testing (manually drive state with network callbacks)
	- callgrind, helgrind profiling
	- Coverage (gcov)
		- link test/foo.c against src/foo.o built with coverage flags
		- ./test/script.sh ?
	- Fuzzing handlers (afl)
	- Try musl C
	- include-what-you-use for header detangling
	- clang tidy, .clang-tidy config

buffer performance improvements:
	- reduce overall size, pack strings in contiguous realloc'ed array
	- cache line breaks
	- pre-format time

abstract list.h from channel/server

SASL auth:
	- cli -a/--auth
	- :connect



----------------------
	/NICKS,
	:IGNORE, :UNIGNORE,
		print the current nicks, ignore list, to the channel
		^(Also print this implicitly when end of nicks numeric is received)
		^(Print as buffer_line type dynamically to fill available terminal space)

FIXME:
----------------------
show connect eta intead of ping when reconnecting

show disconnected/parted in status bar for channels instead of 0 user count

Keep state of tab complete for successively getting the next nick lexicographically

Empty trailing should be null, e.g.:
":nick!~user@host PART #channel :" -> "< ~ nick!~user@host has left #channel ()"

I broke the activity colouring stuff:
	join/part/quit sets activity (it shouldnt)
	message and ping dont set activity (they should)

Some servers place single args in the trailing section, eg: JOIN :channel vs JOIN channel
which forces the handlers to check p->params and p->trailing, however since p->params
is set to NULL in this case, the result is strtok(NULL, " "), so strtok attemps to continue
parsing whatever it last parsed. Instead, a function like strsep should be implemented
which correctly handles NULL input in this case
	-> replace stringtok/stringtok_r with getarg

use the alternate screen buffer to restore screen when rirc exits

##linux ~ cannot send to channel
-- cannot send to '##linux - cannot send to channel'
:::and on each message
	ERR_ERRONEUSNICKNAME: nick is null

messages from chanserv,etc with channel target, e.g.
	:ChanServ!ChanServ@services. NOTICE rcr :[#foo] Welcome to #foo
